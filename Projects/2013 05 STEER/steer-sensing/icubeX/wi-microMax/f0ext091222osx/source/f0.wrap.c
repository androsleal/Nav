//		----------------------------------------------------------//		-- fredrik olofsson 060830								--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h"void *this_class;typedef struct _f0ext {	t_object x_ob;	short x_intswitch;	double x_valIn;	double x_valMin;	double x_valMax;	double x_valOut;	void *x_out;} x_f0ext;void *f0ext_new(t_symbol *s, short ac, t_atom *av);void f0ext_int(x_f0ext *f0ext, long value);void f0ext_float(x_f0ext *f0ext, double value);void f0ext_ft1(x_f0ext *f0ext, double value);void f0ext_ft2(x_f0ext *f0ext, double value);void f0ext_bang(x_f0ext *f0ext);double theFunction(double in, double min, double max, short intswitch);void f0ext_assist(x_f0ext *f0ext, void *box, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((Messlist **)&this_class, (method)f0ext_new, 0L, (short)sizeof(x_f0ext), 0L, A_GIMME, 0);	addbang((method)f0ext_bang);	addint((method)f0ext_int);	addfloat((method)f0ext_float);	addftx((method)f0ext_ft1, 1);	addftx((method)f0ext_ft2, 2);	addmess((method)f0ext_assist, "assist", A_CANT, 0);	finder_addclass("All Objects", "f0.wrap");	finder_addclass("Math", "f0.wrap");	post("f0.wrap v1.0-ub; distributed under GNU GPL license");		//target specific}void *f0ext_new(t_symbol *s, short ac, t_atom *av) {	x_f0ext *f0ext;	f0ext= (x_f0ext *)newobject(this_class);	f0ext->x_valIn= 0;	f0ext->x_intswitch= true;	f0ext->x_valMin= 0;	f0ext->x_valMax= 100;	if(ac>2) {post("warning: f0.wrap %d extra argument(s)", ac-2);}	if(ac==1) {		if(av->a_type==A_FLOAT) {			f0ext->x_intswitch= false;			f0ext->x_valMax= av->a_w.w_float;		} else if(av->a_type==A_LONG) {			f0ext->x_valMax= av->a_w.w_long;		}	}	if(ac>=2) {		if(av->a_type==A_FLOAT) {			f0ext->x_intswitch= false;			f0ext->x_valMin= av->a_w.w_float;		} else if(av->a_type==A_LONG) {			f0ext->x_valMin= av->a_w.w_long;		}		if((av+1)->a_type==A_FLOAT) {			f0ext->x_intswitch= false;			f0ext->x_valMax= (av+1)->a_w.w_float;		} else if((av+1)->a_type==A_LONG) {			f0ext->x_valMax= (av+1)->a_w.w_long;		}	}	f0ext->x_out= floatout(f0ext);	floatin(f0ext, 2);	floatin(f0ext, 1);	return(f0ext);}void f0ext_assist(x_f0ext *f0ext, void *box, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		switch(arg) {			case 0:				sprintf(dst, "number to wrap (int/float)");				break;			case 1:				sprintf(dst, "minimum (float)");				break;			case 2:				sprintf(dst, "maximum (float)");				break;		}	} else if(msg==ASSIST_OUTLET) {		sprintf(dst, "wrapped number (float)");	}}//----------------------------------------------------------------------------------------------void f0ext_int(x_f0ext *f0ext, long value) {	f0ext->x_valIn= value;	f0ext_bang(f0ext);}void f0ext_float(x_f0ext *f0ext, double value) {	f0ext->x_valIn= value;	f0ext_bang(f0ext);}void f0ext_ft1(x_f0ext *f0ext, double value) {	f0ext->x_valMin= value;}void f0ext_ft2(x_f0ext *f0ext, double value) {	f0ext->x_valMax= value;}void f0ext_bang(x_f0ext *f0ext) {	f0ext->x_valOut= theFunction(f0ext->x_valIn, f0ext->x_valMin, f0ext->x_valMax, f0ext->x_intswitch);	outlet_float(f0ext->x_out, f0ext->x_valOut);}//----------------------------------------------------------------------------------------------double theFunction(double in, double min, double max, short intswitch) {	double a, b;	if(min>max) {		a= min;		min= max;		max= a;	}	if(in>=min&&in<=max||min==max) {		a= in;	} else {		b= fabs(max-min);		if(in<min) {			if(intswitch) {				a= max-fabs(fmod(in-min+1, b+1));	//int			} else {				a= max-fabs(fmod(in-min, b));		//float			}		} else {			if(intswitch) {				a= min+fabs(fmod(in-1-max, b+1));	//int			} else {				a= min+fabs(fmod(in-max, b));		//float			}		}	}	return a;}