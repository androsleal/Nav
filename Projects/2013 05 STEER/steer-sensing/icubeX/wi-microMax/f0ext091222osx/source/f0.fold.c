//		----------------------------------------------------------//		-- fredrik olofsson 010502 (rev.011004)					--//		-- updated for carbon using cw8.0 040225				--//		-- updated for wmax using cygwin 051016					--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h" void *this_class;typedef struct _fold {	t_object f_ob;	double f_valueIn;	double f_valueMin;	double f_valueMax;	double f_valueOut;	void *f_out;} f_fold;void *fold_new(double value1, double value2);void fold_int(f_fold *fold, long value);void fold_float(f_fold *fold, double value);void fold_ft1(f_fold *fold, double value);void fold_ft2(f_fold *fold, double value);void fold_bang(f_fold *fold);double foldFunction(double in, double min, double max);void fold_assist(f_fold *fold, Object *f, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((Messlist **)&this_class, (method)fold_new, 0L, (short)sizeof(f_fold), 0L, A_DEFFLOAT, A_DEFFLOAT, 0);		addbang((method)fold_bang);	addint((method)fold_int);	addfloat((method)fold_float);	addftx((method)fold_ft1, 1);	addftx((method)fold_ft2, 2);		addmess((method)fold_assist, "assist", A_CANT, 0);		finder_addclass("All Objects", "f0.fold");	finder_addclass("Math", "f0.fold");		post("f0.fold v1.0.4-ub; distributed under GNU GPL license");		//target specific}void *fold_new(double value1, double value2) {	f_fold *fold;	fold = (f_fold *)newobject(this_class);		fold->f_valueIn = 0;		if (value1 == 0 && value2 == 0) {		fold->f_valueMin = 0;		fold->f_valueMax = 100;		fold->f_valueOut = 0;	} else if (value1 != 0 && value2 == 0) {		fold->f_valueMin = 0;		fold->f_valueMax = value1;		fold->f_valueOut = value1;	} else {		fold->f_valueMin = value1;		fold->f_valueMax = value2;		fold->f_valueOut = 0;	}		fold->f_out = floatout(fold);	floatin(fold, 2);	floatin(fold, 1);		return(fold);}void fold_assist(f_fold *mod, Object *m, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		switch(arg) {			case 0:				sprintf(dst, "number to fold (float)");				break;			case 1:				sprintf(dst, "minimum (float)");				break;			case 2:				sprintf(dst, "maximum (float)");				break;		}	} else if(msg==ASSIST_OUTLET) {		sprintf(dst, "folded number (float)");	}}//----------------------------------------------------------------------------------------------void fold_int(f_fold *fold, long value) {	fold->f_valueIn = value;	fold_bang(fold);}void fold_float(f_fold *fold, double value) {	fold->f_valueIn = value;	fold_bang(fold);}void fold_ft1(f_fold *fold, double value) {	fold->f_valueMin = value;}void fold_ft2(f_fold *fold, double value) {	fold->f_valueMax = value;}void fold_bang(f_fold *fold) {	fold->f_valueOut = foldFunction(fold->f_valueIn, fold->f_valueMin, fold->f_valueMax);	outlet_float(fold->f_out, fold->f_valueOut);}//----------------------------------------------------------------------------------------------double foldFunction(double in, double min, double max) {	double a, b, c;		if (min > max) {		a = min;		min = max;		max = a;	}		if (in >= min && in <= max || min == max)		b = in;		else {		c = fabs(max - min) * 2;		if (in < min) {			a = min - fmod(in - min, c);			if (a >= min && a <= max)				b = a;			else				b = max + (max - a);		} else {			a = max - fmod(in - max, c);			if (a > (min - c / 2) && a <= min)				b = min + (min - a);			else				b = a;		}	}		return b;}