//		----------------------------------------------------------//		-- fredrik olofsson 010502 (rev.011004)					--//		-- updated for carbon using cw8.0 040225				--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h"//#include <math.h>	//target specific - uncomment for classic//#include <time.h>	//target specific - uncomment for windowsvoid *this_class;typedef struct _f0ext {	Object x_ob;	long x_valLeft;	long x_mapping;	long x_variant;	long x_cols;	long x_rows;	long x_width;	long x_height;	double x_stepX;	double x_stepY;	long x_movementX;	long x_movementY;	long x_x;	long x_y;	long x_dx;	long x_dy;	void *x_out;} x_f0ext;void *f0ext_new(void);void f0ext_bang(x_f0ext *f0ext);void f0ext_int(x_f0ext *f0ext, long iterations);void f0ext_mapping(x_f0ext *f0ext, long m);void f0ext_variant(x_f0ext *f0ext, long v);void f0ext_cols(x_f0ext *f0ext, long col);void f0ext_rows(x_f0ext *f0ext, long row);void f0ext_width(x_f0ext *f0ext, long max_X);void f0ext_height(x_f0ext *f0ext, long max_Y);void f0ext_stepX(x_f0ext *f0ext, double stepX);void f0ext_stepY(x_f0ext *f0ext, double stepY);void f0ext_movementX(x_f0ext *f0ext, long movementX);void f0ext_movementY(x_f0ext *f0ext, long movementY);void start(x_f0ext *f0ext);void drawFO(x_f0ext *f0ext);void variant1(x_f0ext *f0ext);void variant2(x_f0ext *f0ext);void variant3(x_f0ext *f0ext);void variant4(x_f0ext *f0ext);void variant5(x_f0ext *f0ext);void variant6(x_f0ext *f0ext);void mapping1(x_f0ext *f0ext, int iCol, int jRow);void mapping2(x_f0ext *f0ext, int iCol, int jRow);void mapping3(x_f0ext *f0ext, int iCol, int jRow);void mapping4(x_f0ext *f0ext, int iCol, int jRow);void mapping5(x_f0ext *f0ext, int i, int iCol, int jRow);void mapping6(x_f0ext *f0ext, int i, int iCol, int jRow);void mapping7(x_f0ext *f0ext, int i, int iCol, int jRow);void mapping8(x_f0ext *f0ext, int j, int iCol, int jRow);void mapping9(x_f0ext *f0ext, int j, int iCol, int jRow);void mapping10(x_f0ext *f0ext, int j, int iCol, int jRow);void mapping11(x_f0ext *f0ext, int i, int j, int iCol, int jRow);void mapping12(x_f0ext *f0ext, int i, int j, int iCol, int jRow);void mapping13(x_f0ext *f0ext, int i, int j, int iCol, int jRow);void mapping14(x_f0ext *f0ext, int i, int j, int iCol, int jRow);void mapping15(x_f0ext *f0ext, int i, int j, int iCol, int jRow);void mapping16(x_f0ext *f0ext, int i, int j, int iCol, int jRow);void slumpaRiktningX(x_f0ext *f0ext);void slumpaRiktningY(x_f0ext *f0ext);void slumpaRiktningXY(x_f0ext *f0ext);int mirrorX(x_f0ext *f0ext, int ox);int mirrorY(x_f0ext *f0ext, int oy);short myRandom();void draw(x_f0ext *f0ext, int ox, int oy);void f0ext_assist(x_f0ext *f0ext, void *box, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((Messlist **)&this_class, (method)f0ext_new, 0L, (short)sizeof(x_f0ext), 0L, 0);	addbang((method)f0ext_bang);	addint((method)f0ext_int);	addmess((method)f0ext_mapping, "mapping", A_DEFLONG, 0);	addmess((method)f0ext_variant, "variant", A_DEFLONG, 0);	addmess((method)f0ext_cols, "cols", A_DEFLONG, 0);	addmess((method)f0ext_rows, "rows", A_DEFLONG, 0);	addmess((method)f0ext_width, "width", A_DEFLONG, 0);	addmess((method)f0ext_height, "height", A_DEFLONG, 0);	addmess((method)f0ext_stepX, "stepX", A_DEFFLOAT, 0);	addmess((method)f0ext_stepY, "stepY", A_DEFFLOAT, 0);	addmess((method)f0ext_movementX, "movementX", A_DEFLONG, 0);	addmess((method)f0ext_movementY, "movementY", A_DEFLONG, 0);	addmess((method)f0ext_assist, "assist", A_CANT, 0);	finder_addclass("All Objects", "f0.construct");	finder_addclass("Graphics", "f0.construct");	post("f0.construct v1.0.4-ub; distributed under GNU GPL license");	//target specific}void *f0ext_new(void) {	x_f0ext *f0ext;	f0ext= (x_f0ext *)newobject(this_class);	f0ext->x_valLeft= 2000;	f0ext->x_mapping= 1;	f0ext->x_variant= 1;	f0ext->x_cols= 3;	f0ext->x_rows= 2;	f0ext->x_width= 200;	f0ext->x_height= 200;	f0ext->x_stepX= 1.0;	f0ext->x_stepY= 1.0;	f0ext->x_movementX= 95;	f0ext->x_movementY= 93;	f0ext->x_x= 10;	f0ext->x_y= 10;	f0ext->x_dx= 1;	f0ext->x_dy= 1;	f0ext->x_out= listout(f0ext);	return(f0ext);}void f0ext_assist(x_f0ext *f0ext, void *box, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		sprintf(dst, "anything");	} else if(msg==ASSIST_OUTLET) {		sprintf(dst, "[x, y, x+1, y+1]");	}}//----------------------------------------------------------------------------------------------void f0ext_mapping(x_f0ext *f0ext, long m) {	if(m>=1&&m<=16) {		f0ext->x_mapping= m;	}}void f0ext_variant(x_f0ext *f0ext, long v) {	if(v>=1&&v<=6) {		f0ext->x_variant= v;	}}void f0ext_cols(x_f0ext *f0ext, long col) {	if(col>=1) {		f0ext->x_cols= col;	}}void f0ext_rows(x_f0ext *f0ext, long row) {	if(row>=1) {		f0ext->x_rows= row;	}}void f0ext_width(x_f0ext *f0ext, long max_X) {	if(max_X>=1) {		f0ext->x_width= max_X;	}}void f0ext_height(x_f0ext *f0ext, long max_Y) {	if(max_Y>=1) {		f0ext->x_height= max_Y;	}}void f0ext_stepX(x_f0ext *f0ext, double stepX) {	f0ext->x_stepX= stepX;}void f0ext_stepY(x_f0ext *f0ext, double stepY) {	f0ext->x_stepY= stepY;}void f0ext_movementX(x_f0ext *f0ext, long movementX) {	if(movementX>=0&&movementX<=100) {		f0ext->x_movementX= movementX;	}}void f0ext_movementY(x_f0ext *f0ext, long movementY) {	if(movementY>=0&&movementY<=100) {		f0ext->x_movementY= movementY;	}}//--void f0ext_int(x_f0ext *f0ext, long iterations) {	if(iterations>=1) {		f0ext->x_valLeft= iterations;		f0ext_bang(f0ext);	}}void f0ext_bang(x_f0ext *f0ext) {	start(f0ext);}//----------------------------------------------------------------------------------------------void start(x_f0ext *f0ext) {	int i;	//srand(time(NULL));			//target specific - uncomment for windows	for(i= 0; i<f0ext->x_valLeft; i++) {		drawFO(f0ext);		f0ext->x_x= f0ext->x_x+(f0ext->x_dx*f0ext->x_stepX);					// flytta position x		if(f0ext->x_x<1) {														// om vŠnster kant			f0ext->x_dx= myRandom()%2;											//   vŠnd eller stŒ still i x-led		} else if(f0ext->x_x>(f0ext->x_width/f0ext->x_cols)) {					// om hšger kant			f0ext->x_dx= 0-(myRandom()%2);										//   vŠnd eller stŒ still i x-led		}		f0ext->x_y= f0ext->x_y+(f0ext->x_dy*f0ext->x_stepY);					// flytta position y		if(f0ext->x_y<1) {														// om švre kanten			f0ext->x_dy= myRandom()%2;											//   vŠnd eller stŒ still i y-led		} else if(f0ext->x_y>(f0ext->x_height/f0ext->x_rows)) {					// om nedre kanten			f0ext->x_dy= 0-(myRandom()%2);										//   vŠnd eller stŒ still i y-led		}		switch(f0ext->x_variant) {			case 1:				variant1(f0ext);				break;			case 2:				variant2(f0ext);				break;			case 3:				variant3(f0ext);				break;			case 4:				variant4(f0ext);				break;			case 5:				variant5(f0ext);				break;			case 6:				variant6(f0ext);				break;		}	}}//----------------------------------------------------------------------------------------------void variant1(x_f0ext *f0ext) {											// 1. slumpa riktningar individuellt	if(myRandom()%100>=f0ext->x_movementX) {		slumpaRiktningX(f0ext);	}	if(myRandom()%100>=f0ext->x_movementY) {		slumpaRiktningY(f0ext);	}}void variant2(x_f0ext *f0ext) {											// 2. slumpa alltid riktningar tillsammans	slumpaRiktningXY(f0ext);}void variant3(x_f0ext *f0ext) {											// 3. slumpa riktningar individuellt	if(myRandom()%100>=f0ext->x_movementX) {		if(f0ext->x_dx==0&&f0ext->x_x>=1) {								//		dra Œt vŠnster			f0ext->x_dx= -1;		} else {			f0ext->x_dx= 0;		}	}	if(myRandom()%100>=f0ext->x_movementY) {		if(f0ext->x_dy==0&&f0ext->x_y>=1) {								//		dra uppŒt			f0ext->x_dy= -1;		} else {			f0ext->x_dy= 0;		}	}}void variant4(x_f0ext *f0ext) {											// 4. slumpa riktningar individuellt	if(myRandom()%100>=f0ext->x_movementX) {		if(f0ext->x_dx==0&&f0ext->x_x>=1) {								//		dra Œt vŠnster			f0ext->x_dx= -1;		} else {			f0ext->x_dx= 0;		}	}	if(myRandom()%100>=f0ext->x_movementY) {		if(f0ext->x_dy==0&&f0ext->x_y<=f0ext->x_height/f0ext->x_rows) {	//		dra nedŒt			f0ext->x_dy= 1;		} else {			f0ext->x_dy= 0;		}	}}void variant5(x_f0ext *f0ext) {											// 5. slumpa riktningar individuellt	if(myRandom()%100>=f0ext->x_movementX) {		if(f0ext->x_dx==0&&f0ext->x_x<=f0ext->x_width/f0ext->x_cols) {	//		dra Œt hšger			f0ext->x_dx= 1;		} else {			f0ext->x_dx= 0;		}	}	if(myRandom()%100>=f0ext->x_movementY) {		if(f0ext->x_dy==0&&f0ext->x_y>=1) {								//		dra uppŒt			f0ext->x_dy= -1;		} else {			f0ext->x_dy= 0;		}	}}void variant6(x_f0ext *f0ext) {											// 6. slumpa riktningar individuellt	if(myRandom()%100>=f0ext->x_movementX) {		if(f0ext->x_dx==0&&f0ext->x_x<=f0ext->x_width/f0ext->x_cols) {	//		dra Œt hšger			f0ext->x_dx= 1;		} else {			f0ext->x_dx= 0;		}	}	if(myRandom()%100>=f0ext->x_movementY) {		if(f0ext->x_dy==0&&f0ext->x_y<=f0ext->x_height/f0ext->x_rows) {	//		dra nedŒt			f0ext->x_dy= 1;		} else {			f0ext->x_dy= 0;		}	}}//----------------------------------------------------------------------------------------------void slumpaRiktningXY(x_f0ext *f0ext) {	while((f0ext->x_dx==0)&&(f0ext->x_dy==0)) {							// kolla att inte bŒda riktningar blir 0		f0ext->x_dx= (myRandom()%3)-1;		f0ext->x_dy= (myRandom()%3)-1;	}}void slumpaRiktningX(x_f0ext *f0ext) {	f0ext->x_dx= (myRandom()%3)-1;}void slumpaRiktningY(x_f0ext *f0ext) {	f0ext->x_dy= (myRandom()%3)-1;}//----------------------------------------------------------------------------------------------void drawFO(x_f0ext *f0ext) {	int i, j, iCol, jRow;	for(i= 0; i<f0ext->x_cols; i++) {		for(j= 0; j<f0ext->x_rows; j++) {			iCol= (f0ext->x_width/f0ext->x_cols)*i;			jRow= (f0ext->x_height/f0ext->x_rows)*j;			switch(f0ext->x_mapping) {									// kolla mapping				case 1:					mapping1(f0ext, iCol, jRow);					break;				case 2:					mapping2(f0ext, iCol, jRow);					break;				case 3:					mapping3(f0ext, iCol, jRow);					break;				case 4:					mapping4(f0ext, iCol, jRow);					break;				case 5:					mapping5(f0ext, i, iCol, jRow);					break;				case 6:					mapping6(f0ext, i, iCol, jRow);					break;				case 7:					mapping7(f0ext, i, iCol, jRow);					break;				case 8:					mapping8(f0ext, j, iCol, jRow);					break;				case 9:					mapping9(f0ext, j, iCol, jRow);					break;				case 10:					mapping10(f0ext, j, iCol, jRow);					break;				case 11:					mapping11(f0ext, i, j, iCol, jRow);					break;				case 12:					mapping12(f0ext, i, j, iCol, jRow);					break;				case 13:					mapping13(f0ext, i, j, iCol, jRow);					break;				case 14:					mapping14(f0ext, i, j, iCol, jRow);					break;				case 15:					mapping15(f0ext, i, j, iCol, jRow);					break;				case 16:					mapping16(f0ext, i, j, iCol, jRow);					break;			}		}	}}//----------------------------------------------------------------------------------------------void mapping1(x_f0ext *f0ext, int iCol, int jRow) {										// no flip	draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);}void mapping2(x_f0ext *f0ext, int iCol, int jRow) {										// flip all x	draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);}void mapping3(x_f0ext *f0ext, int iCol, int jRow) {										// flip all y	draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);}void mapping4(x_f0ext *f0ext, int iCol, int jRow) {										// flip all xy	draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);}//--void mapping5(x_f0ext *f0ext, int i, int iCol, int jRow) {								// flip odd col x	if(i%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping6(x_f0ext *f0ext, int i, int iCol, int jRow) {								// flip odd col y	if(i%2==1) {		draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping7(x_f0ext *f0ext, int i, int iCol, int jRow) {								// flip odd col xy	if(i%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}//--void mapping8(x_f0ext *f0ext, int j, int iCol, int jRow) {								// flip odd row x	if(j%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping9(x_f0ext *f0ext, int j, int iCol, int jRow) {								// flip odd row y	if(j%2==1) {		draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping10(x_f0ext *f0ext, int j, int iCol, int jRow) {								// flip odd row xy	if(j%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}//--void mapping11(x_f0ext *f0ext, int i, int j, int iCol, int jRow) {						// flip odd col & even row x, flip even col & odd row x	if(i%2==1&&j%2==0) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);	} else if(i%2==0&&j%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping12(x_f0ext *f0ext, int i, int j, int iCol, int jRow) {						// flip odd col & even row y, flip even col & odd row y	if(i%2==1&&j%2==0) {		draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else if(i%2==0&&j%2==1) {		draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping13(x_f0ext *f0ext, int i, int j, int iCol, int jRow) {						// flip odd col & even row xy, flip even col & odd row xy	if(i%2==1&&j%2==0) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else if(i%2==0&&j%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}//--void mapping14(x_f0ext *f0ext, int i, int j, int iCol, int jRow) {						// flip even col & even row x, flip odd col & odd row x	if(i%2==0&&j%2==0) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);	} else if(i%2==1&&j%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, f0ext->x_y+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping15(x_f0ext *f0ext, int i, int j, int iCol, int jRow) {						// flip even col & even row y, flip odd col & odd row y	if(i%2==0&&j%2==0) {		draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else if(i%2==1&&j%2==1) {		draw(f0ext, f0ext->x_x+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}void mapping16(x_f0ext *f0ext, int i, int j, int iCol, int jRow) {						// flip even col & even row xy, flip odd col & odd row xy	if(i%2==0&&j%2==0) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else if(i%2==1&&j%2==1) {		draw(f0ext, mirrorX(f0ext, f0ext->x_x)+iCol, mirrorY(f0ext, f0ext->x_y)+jRow);	} else {		draw(f0ext, f0ext->x_x+iCol, f0ext->x_y+jRow);	}}//----------------------------------------------------------------------------------------------int mirrorX(x_f0ext *f0ext, int ox) {	return round((f0ext->x_width/f0ext->x_cols)-ox);}int mirrorY(x_f0ext *f0ext, int oy) {	return round((f0ext->x_height/f0ext->x_rows)-oy);}short myRandom() {	//return (short)fabs(Random());		//target specific	return (short)rand();			//target specific}void draw(x_f0ext *f0ext, int ox, int oy) {	Atom lista[4];	SETLONG(lista, ox);	SETLONG(lista+1, oy);	SETLONG(lista+2, ox+1);	SETLONG(lista+3, oy+1);	outlet_list(f0ext->x_out, 0L, 4, lista);}