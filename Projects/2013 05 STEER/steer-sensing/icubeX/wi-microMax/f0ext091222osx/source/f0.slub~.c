//		----------------------------------------------------------//		-- fredrik olofsson 040331								--//		-- updated for wmax using cygwin 051016					--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h"#include "z_dsp.h"void *this_class;typedef struct _sigobj {	t_pxobject x_obj;	double t_valueRight;	short t_flag;} t_sigobj;void *sigobj_new(double value);t_int *offset_perform(t_int *w);void sigobj_int(t_sigobj *sigobj, long value);void sigobj_float(t_sigobj *sigobj, double value);void sigobj_ft1(t_sigobj *sigobj, double value);void sigobj_bang(t_sigobj *sigobj);void sigobj_dsp(t_sigobj *sigobj, t_signal **sp, short *count);void theFunction(t_sigobj *sigobj);void sigobj_assist(t_sigobj *sigobj, Object *x, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((t_messlist **)&this_class, (method)sigobj_new, (method)dsp_free, (short)sizeof(t_sigobj), 0L, A_DEFFLOAT, 0);		addmess((method)sigobj_dsp, "dsp", A_CANT, 0);	addbang((method)sigobj_bang);	addint((method)sigobj_int);	addfloat((method)sigobj_float);	addftx((method)sigobj_ft1, 1);		addmess((method)sigobj_assist, "assist", A_CANT, 0);	dsp_initclass();		finder_addclass("All Objects", "f0.slub~");	finder_addclass("MSP System", "f0.slub~");		post("f0.slub~ v1.0-ub; distributed under GNU GPL license");		//target specific}void *sigobj_new(double value) {	t_sigobj *sigobj;	sigobj = (t_sigobj *)newobject(this_class);	dsp_setup((t_pxobject *)sigobj, 1);		if (value == 0) {		sigobj->t_valueRight = 5;	} else {		sigobj->t_valueRight = value;	}		floatin(sigobj, 1);		return(sigobj);}void sigobj_assist(t_sigobj *sigobj, Object *x, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		switch(arg) {			case 0:				sprintf(dst, "(bang / float)");				break;			case 1:				sprintf(dst, "spike amount (float)");				break;		}	}}//----------------------------------------------------------------------------------------------void sigobj_int(t_sigobj *sigobj, long value) {	sigobj->t_valueRight = value;	sigobj->t_flag = 1;}void sigobj_float(t_sigobj *sigobj, double value) {	sigobj->t_valueRight = value;	sigobj->t_flag = 1;}void sigobj_bang(t_sigobj *sigobj) {	sigobj->t_flag = 1;}void sigobj_ft1(t_sigobj *sigobj, double value) {	sigobj->t_valueRight = value;}void sigobj_dsp(t_sigobj *sigobj, t_signal **sp, short *count) {	dsp_add(offset_perform, 1, sigobj);}t_int *offset_perform(t_int *w) {	t_sigobj *sigobj = (t_sigobj *)(w[1]);	if (sigobj->t_flag == 1) {		sigobj->t_flag = 0;		theFunction(sigobj);	}		return (w+2);}//----------------------------------------------------------------------------------------------void theFunction(t_sigobj *sigobj) {	long			i					,			j	,			k					,			l	,			x					;			x	=			(long)round					(			pow	(	2	,			sigobj->t_valueRight					)			)	;			for					(			i					=					0						;			i	<					x			;	i++			)					{			for	(j=			0			;					j			<	x	;			j++					)			{		for			(					k			=0			;						k<	x			;					k++			)	{			for								(			l			=					0;			l					<			x	;			l++					)			{	fmod(			l				,			3.1415	)			;					}			}}	}}