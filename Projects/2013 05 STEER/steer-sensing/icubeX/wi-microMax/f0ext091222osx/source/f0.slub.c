//		----------------------------------------------------------//		-- fredrik olofsson 040331								--//		-- updated for wmax using cygwin 051016					--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h"void *this_class;typedef struct _mod {	t_object m_ob;	double m_valueRight;} m_mod;void *mod_new(double value);void mod_int(m_mod *mod, long value);void mod_float(m_mod *mod, double value);void mod_ft1(m_mod *mod, double value);void mod_bang(m_mod *mod);void theFunction(m_mod *mod);void mod_assist(m_mod *mod, Object *m, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((Messlist **)&this_class, (method)mod_new, 0L, (short)sizeof(m_mod), 0L, A_DEFFLOAT, 0);		addbang((method)mod_bang);	addint((method)mod_int);	addfloat((method)mod_float);	addftx((method)mod_ft1, 1);		addmess((method)mod_assist, "assist", A_CANT, 0);		finder_addclass("All Objects", "f0.slub");	finder_addclass("Timing", "f0.slub");		post("f0.slub v1.0-ub; distributed under GNU GPL license");		//target specific}void *mod_new(double value) {	m_mod *mod;	mod = (m_mod *)newobject(this_class);		if (value == 0) {		mod->m_valueRight = 5;	} else {		mod->m_valueRight = value;	}		floatin(mod, 1);		return(mod);}void mod_assist(m_mod *mod, Object *m, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		switch(arg) {			case 0:				sprintf(dst, "(bang / float)");				break;			case 1:				sprintf(dst, "spike amount (float)");				break;		}	}}//----------------------------------------------------------------------------------------------void mod_int(m_mod *mod, long value) {	mod->m_valueRight = value;	theFunction(mod);}void mod_float(m_mod *mod, double value) {	mod->m_valueRight = value;	theFunction(mod);}void mod_bang(m_mod *mod) {	theFunction(mod);}void mod_ft1(m_mod *mod, double value) {	mod->m_valueRight = value;}//----------------------------------------------------------------------------------------------void theFunction(m_mod *mod) {	long			i					,			j	,			k					,			l	,			x					;			x	=			(long)round					(			pow	(	2	,			mod->m_valueRight					)			)	;			for					(			i					=					0						;			i	<					x			;	i++			)					{			for	(j=			0			;					j			<	x	;			j++					)			{		for			(					k			=0			;						k<	x			;					k++			)	{			for								(			l			=					0;			l					<			x	;			l++					)			{	fmod(			l				,			3.1415	)			;					}			}}	}}