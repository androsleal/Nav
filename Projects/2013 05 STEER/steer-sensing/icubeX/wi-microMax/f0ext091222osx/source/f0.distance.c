//		----------------------------------------------------------//		-- fredrik olofsson 010522 (rev.011004)					--//		-- updated for carbon using cw8.0 040225				--//		-- updated for wmax using cygwin 051016					--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h"#define MAXSIZE 3 void *this_class; typedef struct _distance {	t_object d_ob;	Atom d_list[MAXSIZE];	long d_size;	double d_x1;	double d_y1;	double d_z1;	double d_x2;	double d_y2;	double d_z2;	double d_valueOut;	void *d_out;} d_distance;void *distance_new(long value);void distance_float(d_distance *distance, double value);void distance_int(d_distance *distance, long value);void distance_ft1(d_distance *distance, double value);void distance_ft2(d_distance *distance, double value);void distance_list(d_distance *distance, Symbol *s, short ac, Atom *av);void beraknaAvstand(d_distance *distance);void distance_bang(d_distance *distance);void distance_assist(d_distance *distance, Object *d, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((Messlist **)&this_class, (method)distance_new, 0L, (short)sizeof(d_distance), 0L, A_DEFLONG, 0);		addbang((method)distance_bang);	addfloat((method)distance_float);	addint((method)distance_int);	addftx((method)distance_ft1, 1);	addftx((method)distance_ft2, 2);	addmess((method)distance_list, "list", A_GIMME, 0);		addmess((method)distance_assist, "assist", A_CANT, 0);		finder_addclass("All Objects", "f0.distance");	finder_addclass("Math", "f0.distance");		post("f0.distance v1.0.4-ub; distributed under GNU GPL license");		//target specific}void *distance_new(long value) {	d_distance *distance;	distance = (d_distance *)newobject(this_class);	distance->d_x1 = 0;	distance->d_y1 = 0;	distance->d_z1 = 0;	distance->d_x2 = 0;	distance->d_y2 = 0;	distance->d_z2 = 0;		if (value == 2) {		floatin(distance, 1);	} else if (value == 3) {		floatin(distance, 2);		floatin(distance, 1);	}		distance->d_out = floatout(distance);		return(distance);}void distance_assist(d_distance *mod, Object *m, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		switch(arg) {			case 0:				sprintf(dst, "x (float)");				break;			case 1:				sprintf(dst, "y (float)");				break;			case 2:				sprintf(dst, "z (float)");				break;		}	} else if(msg==ASSIST_OUTLET) {		sprintf(dst, "distance between delta (float)");	}}//----------------------------------------------------------------------------------------------void distance_float(d_distance *distance, double value) {	distance->d_x1 = value;	distance_bang(distance);}void distance_int(d_distance *distance, long value) {	distance->d_x1 = value;	distance_bang(distance);}void distance_ft1(d_distance *distance, double value) {	distance->d_y1 = value;}void distance_ft2(d_distance *distance, double value) {	distance->d_z1 = value;}void distance_list(d_distance *distance, Symbol *s, short ac, Atom *av) {	register short i;	if (ac > MAXSIZE)		ac = MAXSIZE;		for (i = 0; i < ac; i++, av++)		if (av->a_type == A_LONG)			switch (i) {				case 0:					distance->d_x1 = av->a_w.w_long;					break;				case 1:							distance->d_y1 = av->a_w.w_long;					break;				case 2:					distance->d_z1 = av->a_w.w_long;					break;			}		else if (av->a_type == A_FLOAT)			switch (i) {				case 0:					distance->d_x1 = av->a_w.w_float;					break;				case 1:							distance->d_y1 = av->a_w.w_float;					break;				case 2:					distance->d_z1 = av->a_w.w_float;					break;			}		distance_bang(distance);}void distance_bang(d_distance *distance) {	beraknaAvstand(distance);	outlet_float(distance->d_out, distance->d_valueOut);}//----------------------------------------------------------------------------------------------void beraknaAvstand(d_distance *distance) {	double x, y, z;		x = distance->d_x1 - distance->d_x2;	y = distance->d_y1 - distance->d_y2;	z = distance->d_z1 - distance->d_z2;	distance->d_valueOut = fabs(sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2)));		distance->d_x2 = distance->d_x1;	distance->d_y2 = distance->d_y1;	distance->d_z2 = distance->d_z1;}