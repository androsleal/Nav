//		----------------------------------------------------------//		-- fredrik olofsson 040226								--//		-- converted from abstraction with the same name		--//		-- updated for wmax using cygwin 051016					--//		-- updated for ub using xcode 070103					--//		-- distributed under GNU GPL license					--//		----------------------------------------------------------#include "ext.h"//#define LONG_MIN -2147483647		//target specific - uncomment for windows//#define LONG_MAX 2147483647void *this_class;typedef struct _mod {	t_object m_ob;	long m_valueCount;	long m_valueMin;	long m_valueMax;	void *m_out;	void *m_out2;	void *m_out3;} m_mod;void *mod_new(long value1, long value2);void mod_int(m_mod *mod, long value);void mod_in2(m_mod *mod, long value);void mod_in3(m_mod *mod, long value);void mod_bang(m_mod *mod);void mod_bang2(m_mod *mod);void mod_assist(m_mod *mod, Object *m, long msg, long arg, char *dst);//----------------------------------------------------------------------------------------------void main(void) {	setup((Messlist **)&this_class, (method)mod_new, 0L, (short)sizeof(m_mod), 0L, A_DEFLONG, A_DEFLONG, 0);		addbang((method)mod_bang);	addmess((method)mod_bang2, "bang2", 0);	addint((method)mod_int);	addinx((method)mod_in2, 2);	addinx((method)mod_in3, 3);		addmess((method)mod_assist, "assist", A_CANT, 0);		finder_addclass("All Objects", "f0.limit_counter");	finder_addclass("Control", "f0.limit_counter");		post("f0.limit_counter v1.0-ub; distributed under GNU GPL license");		//target specific}void *mod_new(long value1, long value2) {	m_mod *mod;		mod = (m_mod *)newobject(this_class);	mod->m_valueCount = 0;		if (value1 == 0 && value2 == 0) {		mod->m_valueMin = LONG_MIN;		mod->m_valueMax = LONG_MAX;	} else if (value1 != 0 && value2 == 0) {		mod->m_valueMin = value1;		mod->m_valueMax = LONG_MAX;	} else {		mod->m_valueMin = value1;		mod->m_valueMax = value2;	}		mod->m_out3 = bangout(mod);	mod->m_out2 = bangout(mod);	mod->m_out = intout(mod);	intin(mod, 3);	intin(mod, 2);	inlet4(mod, mod, "bang", "bang2");		return(mod);}void mod_assist(m_mod *mod, Object *m, long msg, long arg, char *dst) {	if(msg==ASSIST_INLET) {		switch(arg) {			case 0:				sprintf(dst, "increase (bang), set value (int)");				break;			case 1:				sprintf(dst, "decrease (bang)");				break;			case 2:				sprintf(dst, "floor value (int)");				break;			case 3:				sprintf(dst, "ceil value (int)");				break;		}	} else if(msg==ASSIST_OUTLET) {		switch(arg) {			case 0:				sprintf(dst, "counter (int)");				break;			case 1:				sprintf(dst, "counter hits floor (bang)");				break;			case 2:				sprintf(dst, "counter hits ceil (bang)");				break;		}	}}//----------------------------------------------------------------------------------------------void mod_int(m_mod *mod, long value) {	if (value < mod->m_valueMin) {		value= mod->m_valueMin;	} else if (value > mod->m_valueMax) {		value= mod->m_valueMax;	}	mod->m_valueCount = value;}void mod_in2(m_mod *mod, long value) {	mod->m_valueMin = value;	if (mod->m_valueCount < value) {		mod->m_valueCount = value;	}}void mod_in3(m_mod *mod, long value) {	mod->m_valueMax = value;	if (mod->m_valueCount > value) {		mod->m_valueCount = value;	}}//----------------------------------------------------------------------------------------------void mod_bang(m_mod *mod) {	if (mod->m_valueCount < mod->m_valueMax) {		mod->m_valueCount = mod->m_valueCount+1;	}	if (mod->m_valueCount == mod->m_valueMax) {		outlet_bang(mod->m_out3);	}	outlet_int(mod->m_out, mod->m_valueCount);}void mod_bang2(m_mod *mod) {	if (mod->m_valueCount > mod->m_valueMin) {		mod->m_valueCount = mod->m_valueCount-1;	}	if (mod->m_valueCount == mod->m_valueMin) {		outlet_bang(mod->m_out2);	}	outlet_int(mod->m_out, mod->m_valueCount);}